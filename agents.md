# Agents Guide - CareBot Project

Этот файл содержит принципы и соглашения для разработчиков и AI агентов, работающих с проектом CareBot.

## Миграции базы данных

### Структура миграций

Все миграции базы данных должны храниться в папке `CareBot/CareBot/database/migrations/` и следовать определенной схеме именования:

```
database/
└── migrations/
    ├── 001_add_winner_bonus_column.sql
    ├── 001_migrate_winner_bonus.py
    ├── 002_next_migration.sql
    └── 002_next_migration.py
```

### Принципы именования миграций

1. **Номер миграции** - трехзначное число в начале имени (001, 002, 003, ...)
2. **Описательное название** - краткое описание изменений в snake_case
3. **Расширение файла**:
   - `.sql` - для чистых SQL скриптов
   - `.py` - для сложных миграций с логикой

### Примеры правильного именования

- `001_add_winner_bonus_column.sql` - добавление колонки winner_bonus
- `002_create_warehouses_table.sql` - создание таблицы складов
- `003_migrate_user_data.py` - сложная миграция пользовательских данных
- `004_add_battle_rewards_index.sql` - добавление индекса для наград

### Содержимое миграций

#### SQL миграции
Простые SQL скрипты для изменения структуры таблиц:
```sql
-- 001_add_winner_bonus_column.sql
-- Add winner_bonus column to mission_stack table
ALTER TABLE mission_stack ADD COLUMN winner_bonus TEXT;
```

#### Python миграции
Для сложной логики миграции с проверками и обновлением данных:
```python
# 001_migrate_winner_bonus.py
"""
Migration script to add winner_bonus column and update existing records.
"""
import aiosqlite
import asyncio
import os

async def migrate_database():
    # Проверка существования колонки
    # Добавление колонки если нужно
    # Миграция данных
    pass
```

### Правила применения миграций

1. **Последовательность** - миграции должны применяться строго по порядку номеров
2. **Идемпотентность** - миграция должна безопасно выполняться повторно
3. **Откат** - при возможности предусмотреть возможность отката изменений
4. **Тестирование** - всегда тестировать миграции на копии базы данных

### Работа с winner_bonus

Специальные правила для работы с наградами победителей:

- `winner_bonus` хранится в таблице `mission_stack`
- Это **секретная** информация, недоступная до окончания битвы
- Используйте `get_winner_bonus(mission_id)` для получения после определения победителя
- НЕ возвращайте winner_bonus в `get_mission_details()`

## Структура миссий

### Типы миссий и их награды

#### Kill Team миссии:
- `Loot` - оба получают 1 ресурс, победитель дополнительные ресурсы
- `Transmission` - победитель получает ресурсы равные ресурсам противника
- `Secure` - победитель получает 2 ресурса
- `Intel` - создает склад в гексе миссии
- `Sabotage` - нет изменений ресурсов
- `Extraction` - победитель +1 ресурс, проигравший -1 ресурс
- `Power Surge` - проигравший теряет ресурсы равные количеству складов (минимум 1)
- `Coordinates` - проигравший теряет ресурсы + один склад уничтожается

#### WH40K миссии:
- Имеют секретный `winner_bonus` который раскрывается только победителю
- Примеры бонусов: дополнительный опыт для юнитов, бонусы к следующим битвам

### Функции для работы с миссиями

- `generate_new_one(rules)` - создает новую миссию с бонусом для wh40k
- `get_mission(rules)` - получает миссию без раскрытия секретов
- `apply_mission_rewards()` - применяет награды и раскрывает секретные бонусы
- `get_winner_bonus(mission_id)` - получает секретный бонус (только после битвы!)

## Соглашения по коду

### База данных
- Используйте `aiosqlite` для асинхронного доступа к SQLite
- Всегда используйте параметризованные запросы для предотвращения SQL-инъекций
- Закрывайте соединения с базой данных (`async with aiosqlite.connect()`)

### Логирование
- Используйте `logging` для отслеживания важных операций
- Особенно важно логировать применение наград и изменения ресурсов

### Обработка ошибок
- Проверяйте существование записей перед их использованием
- Graceful degradation при отсутствии данных
- Логируйте ошибки для отладки

## Деплой и инфраструктура

### Docker деплой
- Приложение упаковывается в Docker контейнер
- База данных SQLite монтируется как volume для персистентности
- Используйте `scripts/deploy.ps1` для автоматического деплоя

### Скрипты управления

#### Деплой
- `scripts/deploy.ps1` - основной скрипт деплоя на Ubuntu сервер
- `scripts/test-local.ps1` - локальное тестирование Docker образа

#### Мониторинг
- `scripts/monitor.ps1` - мониторинг состояния приложения
- `scripts/db-access.ps1` - доступ к базе данных с локальной машины

#### Endpoints
- `/health` - health check для мониторинга
- Возвращает статус приложения и базы данных

### Переменные окружения
- `DATABASE_PATH` - путь к файлу базы данных SQLite
- `SERVER_HOST` - хост для привязки сервера (0.0.0.0 в продакшене)
- `SERVER_PORT` - порт сервера (по умолчанию 5555)

---

*Этот документ должен обновляться при добавлении новых соглашений и принципов работы с проектом.*